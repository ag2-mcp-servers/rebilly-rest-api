# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T08:54:44+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity, HTTPBearer
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    Accept,
    AmlGetResponse,
    Attachment,
    AttachmentsGetResponse,
    AuthenticationOptions,
    AuthenticationOptionsGetResponse,
    AuthenticationToken,
    AuthenticationTokensGetResponse,
    BankAccount,
    BankAccountsGetResponse,
    BankAccountsIdPutRequest,
    BankAccountsPostRequest,
    BankAccountUpdatePlain,
    Blocklist,
    BlocklistsGetResponse,
    CompositeToken,
    CoreReadyToPay,
    Coupon,
    CouponExpiration,
    CouponRedemption,
    CouponsGetResponse,
    CouponsRedemptionsGetResponse,
    Credential,
    CredentialsGetResponse,
    Customer,
    CustomerJWT,
    CustomersGetResponse,
    CustomersIdTimelineGetResponse,
    CustomersIdUpcomingInvoicesGetResponse,
    CustomerTimeline,
    CustomerTimelineCustomEvent,
    CustomerTimelineCustomEventsGetResponse,
    CustomerTimelineEventsGetResponse,
    CustomField,
    CustomFieldsResourceGetResponse,
    DigitalWalletValidation,
    Dispute,
    DisputesGetResponse,
    Error,
    Extension,
    Field3dsecureGetResponse,
    File,
    FilesGetResponse,
    FilesPostRequest,
    InvalidError,
    Invoice,
    InvoiceIssue,
    InvoiceItem,
    InvoiceReissue,
    InvoicesGetResponse,
    InvoicesIdItemsGetResponse,
    InvoicesIdTimelineGetResponse,
    InvoicesIdTransactionAllocationsGetResponse,
    InvoiceTimeline,
    InvoiceTransaction,
    KycDocument2,
    KycDocumentRejection,
    KycDocumentsGetResponse,
    KycDocumentsIdMatchesPostRequest,
    KycRequest,
    KycRequestsGetResponse,
    LeadSource,
    OrderTimeline,
    PasswordTokensGetResponse,
    PaymentCard,
    PaymentCardsGetResponse,
    PaymentCardsIdPutRequest,
    PaymentCardsPostRequest,
    PaymentCardUpdatePlain,
    PaymentInstrument21,
    PaymentInstrumentsGetResponse,
    PaymentInstrumentsIdPatchRequest,
    PaymentInstrumentsPostRequest,
    PayoutRequest,
    PayPalAccount,
    PaypalAccountsGetResponse,
    Plan,
    PlansGetResponse,
    Product,
    ProductsGetResponse,
    ReadyToPayMethods,
    ResetPasswordToken,
    Resource,
    ResourceId,
    SearchGetResponse,
    ShippingZone,
    ShippingZonesGetResponse,
    Sort,
    Subscription,
    SubscriptionCancellation,
    SubscriptionCancellationsGetResponse,
    SubscriptionChange,
    SubscriptionInvoice,
    SubscriptionReactivation,
    SubscriptionReactivationsGetResponse,
    SubscriptionsGetResponse,
    SubscriptionsIdTimelineGetResponse,
    SubscriptionsIdUpcomingInvoicesGetResponse,
    Tag,
    TagsGetResponse,
    TagsTagCustomersDeleteRequest,
    TagsTagCustomersPostRequest,
    ThreeDSecure,
    TokensGetResponse,
    Transaction,
    TransactionQuery,
    TransactionRefund,
    TransactionRequest,
    TransactionsGetResponse,
    TransactionsIdPatchRequest,
    TransactionsIdTimelineGetResponse,
    TransactionTimeline,
    TransactionUpdate,
)

app = MCPProxy(
    contact={
        'email': 'integrations@rebilly.com',
        'name': 'Rebilly API Support',
        'url': 'https://www.rebilly.com/contact/',
    },
    description='# Introduction\nThe Rebilly API is built on HTTP.  Our API is RESTful.  It has predictable\nresource URLs.  It returns HTTP response codes to indicate errors.  It also\naccepts and returns JSON in the HTTP body.  You can use your favorite\nHTTP/REST library for your programming language to use Rebilly\'s API, or\nyou can use one of our SDKs (currently available in [PHP](https://github.com/Rebilly/rebilly-php)\nand [Javascript](https://github.com/Rebilly/rebilly-js-sdk)).\n\nWe have other APIs that are also available.  Every action from our [app](https://app.rebilly.com)\nis supported by an API which is documented and available for use so that you\nmay automate any workflows necessary.  This document contains the most commonly\nintegrated resources.\n\n# Authentication\n\nWhen you sign up for an account, you are given your first secret API key.\nYou can generate additional API keys, and delete API keys (as you may\nneed to rotate your keys in the future). You authenticate to the\nRebilly API by providing your secret key in the request header.\n\nRebilly offers three forms of authentication:  secret key, publishable key, JSON Web Tokens, and public signature key.\n- [Secret API key](#section/Authentication/SecretApiKey): used for requests made\n  from the server side. Never share these keys. Keep them guarded and secure.\n- [Publishable API key](#section/Authentication/PublishableApiKey): used for \n  requests from the client side. For now can only be used to create \n  a [Payment Token](#operation/PostToken) and \n  a [File token](#operation/PostFile).\n- [JWT](#section/Authentication/JWT): short lifetime tokens that can be assigned a specific expiration time.\n\nNever share your secret keys. Keep them guarded and secure.\n\n&lt;!-- ReDoc-Inject: &lt;security-definitions&gt; --&gt;\n\n# Errors\nRebilly follow\'s the error response format proposed in [RFC 7807](https://tools.ietf.org/html/rfc7807) also known as Problem Details for HTTP APIs.  As with our normal API responses, your client must be prepared to gracefully handle additional members of the response.\n\n## Forbidden\n&lt;RedocResponse pointer={"#/components/responses/Forbidden"} /&gt;\n\n## Conflict\n&lt;RedocResponse pointer={"#/components/responses/Conflict"} /&gt;\n\n## NotFound\n&lt;RedocResponse pointer={"#/components/responses/NotFound"} /&gt;\n\n## Unauthorized\n&lt;RedocResponse pointer={"#/components/responses/Unauthorized"} /&gt;\n\n## ValidationError\n&lt;RedocResponse pointer={"#/components/responses/ValidationError"} /&gt;\n\n# SDKs\n\nRebilly offers a Javascript SDK and a PHP SDK to help interact with\nthe API.  However, no SDK is required to use the API.\n\nRebilly also offers [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/),\n a client-side iFrame-based solution to help\ncreate payment tokens while minimizing PCI DSS compliance burdens\nand maximizing the customizability. [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/)\nis interacting with the [payment tokens creation operation](#operation/PostToken).\n\n## Javascript SDK\n\nInstallation and usage instructions can be found [here](https://docs.rebilly.com/docs/developer-docs/sdks).\nSDK code examples are included in these docs.\n\n## PHP SDK\nFor all PHP SDK examples provided in these docs you will need to configure the `$client`.\nYou may do it like this:\n\n```php\n$client = new Rebilly\\Client([\n    \'apiKey\' =&gt; \'YourApiKeyHere\',\n    \'baseUrl\' =&gt; \'https://api.rebilly.com\',\n]);\n```\n\n# Using filter with collections\nRebilly provides collections filtering. You can use `?filter` param on collections to define which records should be shown in the response.\n\nHere is filter format description:\n\n- Fields and values in filter are separated with `:`: `?filter=firstName:John`.\n\n- Sub-fields are separated with `.`: `?filter=billingAddress.country:US`.\n\n- Multiple filters are separated with `;`: `?filter=firstName:John;lastName:Doe`. They will be joined with `AND` logic. In this example: `firstName:John` AND `lastName:Doe`.\n\n- You can use multiple values using `,` as values separator: `?filter=firstName:John,Bob`. Multiple values specified for a field will be joined with `OR` logic. In this example: `firstName:John` OR `firstName:Bob`.\n\n- To negate the filter use `!`: `?filter=firstName:!John`. Note that you can negate multiple values like this: `?filter=firstName:!John,!Bob`. This filter rule will exclude all Johns and Bobs from the response.\n\n- You can use range filters like this: `?filter=amount:1..10`.\n\n- You can use gte (greater than or equals) filter like this: `?filter=amount:1..`, or lte (less than or equals) than filter like this: `?filter=amount:..10`. This also works for datetime-based fields.\n\n- You can create some [predefined values lists](https://user-api-docs.rebilly.com/#tag/Lists) and use them in filter: `?filter=firstName:@yourListName`. You can also exclude list values: `?filter=firstName:!@yourListName`.\n\n- Datetime-based fields accept values formatted using RFC 3339 like this: `?filter=createdTime:2021-02-14T13:30:00Z`. \n\n# Expand to include embedded objects\nRebilly provides the ability to pre-load additional \nobjects with a request. \n\nYou can use `?expand` param on most requests to expand\nand include embedded objects within the\n`_embedded` property of the response.\n\nThe `_embedded` property contains an array of \nobjects keyed by the expand parameter value(s).\n\nYou may expand multiple objects by passing them\nas comma-separated to the expand value like so:\n\n```\n?expand=recentInvoice,customer\n```\n\nAnd in the response, you would see:\n\n```\n"_embedded": [\n    "recentInvoice": {...},\n    "customer": {...}\n]\n```\nExpand may be utilitized not only on `GET` requests but also on `PATCH`, `POST`, `PUT` requests too.\n\n\n# Getting started guide\n\nRebilly\'s API has over 300 operations.  That\'s more than you\'ll \nneed to implement your use cases.  If you have a use \ncase you would like to implement, please consult us for\nfeedback on the best API operations for the task.\n\nOur getting started guide will demonstrate a basic order form use\ncase.  It will allow us to highlight core resources\nin Rebilly that will be helpful for many other use cases\ntoo.\n\nWithin 25 minutes, you\'ll have sent API requests (via our console)\nto create a subscription order.\n',
    license={'name': 'Rebilly', 'url': 'https://www.rebilly.com/api-license/'},
    termsOfService='https://www.rebilly.com/terms-of-use/',
    title='Rebilly REST API',
    version='2.1',
    servers=[
        {'description': 'Sandbox Server.', 'url': 'https://api-sandbox.rebilly.com'},
        {'description': 'Live Server.', 'url': 'https://api.rebilly.com'},
    ],
)


@app.get(
    '/3dsecure',
    tags=['three_d_secure_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get3_d_secure_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of ThreeDSecure entries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/3dsecure',
    description=""" Create a ThreeDSecure entry.
 """,
    tags=['three_d_secure_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post3_d_secure(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: ThreeDSecure = ...,
):
    """
    Create a ThreeDSecure entry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/3dsecure/{id}',
    description=""" Retrieve a ThreeDSecure entry with specified identifier string.
 """,
    tags=['three_d_secure_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get3_d_secure(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a ThreeDSecure entry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/aml',
    description=""" Search multiple PEP/Sanctions/Adverse Media lists with first and last name to find any blocklisted identities.
Performs a fuzzy search including soundex. Not all fields are guaranteed to be filled.
 """,
    tags=['aml_search'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_aml_entry(
    organization__id: Union[
        Optional[ResourceId],
        Optional[ResourceId],
        Optional[ResourceId],
        Optional[ResourceId],
    ] = Header(None, alias='Organization-Id'),
    first_name: str = Query(..., alias='firstName'),
    last_name: str = Query(..., alias='lastName'),
    dob: Optional[str] = None,
    country: Optional[str] = None,
):
    """
    Search PEP/Sanctions/Adverse Media lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/attachments',
    description=""" Retrieve a list of attachments.
You may sort by the id, name, relatedId, relatedType, fileId, createdTime, and updatedTime.
 """,
    tags=['attachment_management', 'file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_attachment_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    fields: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of Attachments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/attachments',
    description=""" Create an Attachment.
 """,
    tags=['attachment_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_attachment(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Attachment = ...,
):
    """
    Create an Attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/attachments/{id}',
    description=""" Delete the Attachment with predefined identifier string.
 """,
    tags=['attachment_management', 'file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_attachment(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete an Attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/attachments/{id}',
    description=""" Retrieve a Attachment with specified identifier string.
 """,
    tags=['attachment_management', 'file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_attachment(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an Attachment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/attachments/{id}',
    description=""" Update the Attachment with predefined ID.
 """,
    tags=['attachment_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_attachment(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Attachment = ...,
):
    """
    Update the Attachment with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/authentication-options',
    description=""" Read current authentication options.
 """,
    tags=['authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_authentication_option(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id')
):
    """
    Read current authentication options
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/authentication-options',
    description=""" Change options.
 """,
    tags=['authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_authentication_option(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: AuthenticationOptions = ...,
):
    """
    Change authentication options
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/authentication-tokens',
    description=""" Retrieve a list of auth tokens.
 """,
    tags=['authentication_management', 'token_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_authentication_token_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of auth tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authentication-tokens',
    description=""" Login a customer.
 """,
    tags=['authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_authentication_token(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: AuthenticationToken = ...,
):
    """
    Login
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/authentication-tokens/{token}',
    description=""" Logout a customer.
 """,
    tags=['authentication_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_authentication_token(
    token: str,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Logout a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/authentication-tokens/{token}',
    description=""" Verify an authentication token.
 """,
    tags=['authentication_management', 'token_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def get_authentication_token_verification(
    token: str,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Verify
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authentication-tokens/{token}/exchange',
    description=""" Exchange Authentication Token for JWT.

It will also invalidate an Authentication Token by default (so it can only be exchanged once).
 """,
    tags=['authentication_management', 'token_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_authentication_token_exchange(
    token: str,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CustomerJWT = ...,
):
    """
    Exchange
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bank-accounts',
    description=""" Retrieve a list of Bank Accounts.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_bank_account_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = None,
    filter: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of bank accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bank-accounts',
    description=""" Create a Bank Account.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_bank_account(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: BankAccountsPostRequest = ...,
):
    """
    Create a Bank Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bank-accounts/{id}',
    description=""" Retrieve a Bank Account with specified identifier string.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_bank_account(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Bank Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/bank-accounts/{id}',
    description=""" Update bank account's values except for the account number and routing. number.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_bank_account(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: BankAccountUpdatePlain = None,
):
    """
    Update a bank account's values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/bank-accounts/{id}',
    description=""" Create or update a BankAccount with predefined identifier string.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_bank_account(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: BankAccountsIdPutRequest = ...,
):
    """
    Create a Bank Account with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bank-accounts/{id}/deactivation',
    description=""" Deactivate a Bank Account.
 """,
    tags=['bank_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_bank_account_deactivation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Deactivate a Bank Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/blocklists',
    description=""" Retrieve a list of blocklists.
 """,
    tags=['blocklist_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_blocklist_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    sort: Optional[Sort] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of blocklists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/blocklists',
    description=""" Create a blocklist.
 """,
    tags=['blocklist_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_blocklist(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Blocklist = ...,
):
    """
    Create a blocklist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/blocklists/{id}',
    description=""" Delete a blocklist with predefined identifier string.
 """,
    tags=['blocklist_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_blocklist(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a blocklist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/blocklists/{id}',
    description=""" Retrieve a blocklist with specified identifier string.
 """,
    tags=['blocklist_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_blocklist(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a blocklist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/blocklists/{id}',
    description=""" Create a blocklist with predefined identifier string.
 """,
    tags=['blocklist_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_blocklist(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Blocklist = ...,
):
    """
    Create a blocklist with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coupons',
    description=""" Retrieve a list of coupons.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_coupon_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of coupons
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/coupons',
    description=""" Create a coupon.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_coupon(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Coupon = ...,
):
    """
    Create a coupon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coupons-redemptions',
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_coupon_redemption_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of coupon redemptions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/coupons-redemptions',
    description=""" Redeem a coupon.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_coupon_redemption(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CouponRedemption = ...,
):
    """
    Redeem a coupon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coupons-redemptions/{id}',
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_coupon_redemption(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a coupon redemption with specified identifier string
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/coupons-redemptions/{id}/cancel',
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_coupon_redemption_cancellation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Cancel a coupon redemption
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/coupons/{id}',
    description=""" Retrieve a coupon with specified coupon ID string.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_coupon(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a coupon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/coupons/{id}',
    description=""" Create or update a coupon with predefined coupon ID.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_coupon(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Coupon = ...,
):
    """
    Create or update a coupon with predefined coupon ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/coupons/{id}/expiration',
    description=""" Set a coupon's expiry time with the specified coupon ID.
The expiredTime of a coupon must be greater than its issuedTime.
This cannot be performed on expired coupons.
 """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_coupon_expiration(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CouponExpiration = None,
):
    """
    Set a coupon's expiration time
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credentials',
    description=""" Retrieve a list of credentials.
 """,
    tags=['credential_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_credential_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/credentials',
    description=""" Create a credential.
 """,
    tags=['credential_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_credential(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Credential = ...,
):
    """
    Create a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/credentials/{id}',
    description=""" Delete a credential with predefined identifier string.
 """,
    tags=['credential_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_credential(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/credentials/{id}',
    description=""" Retrieve a credential with specified identifier string.
 """,
    tags=['credential_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_credential(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/credentials/{id}',
    description=""" Create or update a credential with predefined identifier string.
 """,
    tags=['credential_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_credential(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Credential = ...,
):
    """
    Create or update a credential with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/custom-fields/{resource}',
    description=""" Retrieve a schema of Custom Fields for the given resource type.
 """,
    tags=['custom_field_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_custom_field_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    resource: Resource = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve Custom Fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/custom-fields/{resource}/{name}',
    description=""" Retrieve a schema of the given Custom Field for the given resource type.
 """,
    tags=['custom_field_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_custom_field(
    resource: Resource,
    name: constr(pattern=r'^[\w-]+$', max_length=60) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Custom Field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/custom-fields/{resource}/{name}',
    description=""" Create or alter a schema of the given Custom Field for the given resource. type.
 """,
    tags=['custom_field_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_custom_field(
    resource: Resource,
    name: constr(pattern=r'^[\w-]+$', max_length=60) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CustomField = ...,
):
    """
    Create or alter a Custom Field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customer-timeline-custom-events',
    description=""" Retrieve a list of customer timeline custom event types.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_timeline_custom_event_type_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of customer timeline custom event types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/customer-timeline-custom-events',
    description=""" Create Customer Timeline custom event type.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_customer_timeline_custom_event_type(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CustomerTimelineCustomEvent = ...,
):
    """
    Create Customer Timeline custom event type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customer-timeline-custom-events/{id}',
    description=""" Retrieve customer timeline custom event type.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_timeline_custom_event_type(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve customer timeline custom event type with specified identifier string
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customer-timeline-events',
    description=""" Retrieve a list of customer timeline messages for all customers.
 """,
    tags=['customer_timeline_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_timeline_event_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of customer timeline messages for all customers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers',
    description=""" Retrieve a list of customers.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    fields: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of customers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/customers',
    description=""" Create a customer without a predefined ID.
The customer's primary address
will be used as the default address for payment
instruments, subscriptions and invoices if none
are provided.

If you wish to create the customer with a predefined
ID (which we recommend to prevent duplication), you
may use our `PUT` request described below.

Read our guide to [preventing duplicates](https://api-guides.rebilly.com/core-concepts/preventing-duplicates)
to understand more.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_customer(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Customer = ...,
):
    """
    Create a customer (without an ID)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/customers/{id}',
    description=""" Merge one duplicate customer to another target customer and delete the. former. """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_customer(
    target_customer_id: str = Query(..., alias='targetCustomerId'),
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Merge and delete a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers/{id}',
    description=""" Retrieve a customer with specified identifier string.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer(
    expand: Optional[str] = None,
    fields: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/customers/{id}',
    description=""" Create or update (upsert) a customer with predefined identifier string.
Read our guide to [preventing duplicates](https://api-guides.rebilly.com/core-concepts/preventing-duplicates)
to understand more.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_customer(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Customer = ...,
):
    """
    Upsert a customer with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/customers/{id}/lead-source',
    description=""" Delete a Lead Source that belongs to a certain customer.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_customer_lead_source(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a Lead Source for a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers/{id}/lead-source',
    description=""" Retrieve a Lead Source of given customer.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_lead_source(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a customer's Lead Source
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/customers/{id}/lead-source',
    description=""" Create a Lead Source for a customer.
 """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_customer_lead_source(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: LeadSource = ...,
):
    """
    Create a Lead Source for a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers/{id}/timeline',
    description=""" Retrieve a list of customer timeline messages.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_timeline_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    q: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of customer timeline messages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/customers/{id}/timeline',
    description=""" Create a customer Timeline comment or custom defined event.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_customer_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CustomerTimeline = ...,
):
    """
    Create a customer Timeline comment or custom defined event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/customers/{id}/timeline/{messageId}',
    description=""" Delete a Customer Timeline message with predefined identifier string.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_customer_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a Customer Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers/{id}/timeline/{messageId}',
    description=""" Retrieve a customer message with specified identifier string.
 """,
    tags=['customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a customer Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/customers/{id}/upcoming-invoices',
    description=""" Retrieve a list of upcoming invoices from the subscriptions which belong to. the given customer.
The endpoint is temporary before upcoming invoices get a complete integration.
 """,
    tags=['customer_invoice_management', 'invoice_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_customer_upcoming_invoice_collection(
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve customer's upcoming invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/digital-wallets/validation',
    description=""" [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/)
is the recommended way to use when validating a digital wallet session.
 """,
    tags=['digital_wallet_validation', 'authentication_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_digital_wallet_validation(body: DigitalWalletValidation):
    """
    Validate a digital wallet session
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/disputes',
    description=""" Retrieve a list of disputes.
 """,
    tags=['dispute_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_dispute_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of disputes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/disputes',
    description=""" Create a dispute.
 """,
    tags=['dispute_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_dispute(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Dispute = ...,
):
    """
    Create a dispute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/disputes/{id}',
    description=""" Retrieve a dispute with specified identifier string.
 """,
    tags=['dispute_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_dispute(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a dispute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/disputes/{id}',
    description=""" Create or update a Dispute with predefined identifier string.
 """,
    tags=['dispute_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_dispute(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Dispute = ...,
):
    """
    Create or update a Dispute with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files',
    description=""" Retrieve a list of files.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_file_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    fields: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files',
    description=""" Additionally, a file can be sent with:.
 - multipart/form-data POST request: in this case all property names are the same as the JSON ones (`file` is an uploaded file)
 - file body request: the file body is sent as the request body, with the appropriate `Content-Type`. No additional
 properties can be set along the request data

The following file types only are allowed:
 - jpg
 - png
 - gif
 - pdf
 - mp3


If using a Publishable Api Key, only private files can be created. The files can later on be modified or used using
 a secret API key.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
        APIKeyHeader(name="Authorization"),
    ],
)
def post_file(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: FilesPostRequest = ...,
):
    """
    Create a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/files/{id}',
    description=""" Delete the File with predefined identifier string.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_file(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a File
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{id}',
    description=""" Retrieve a File with specified identifier string.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_file(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a File Record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/files/{id}',
    description=""" Update the File with predefined ID. Note that file can be uploaded with POST. only.
 """,
    tags=['attachment_management', 'file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_file(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: File = ...,
):
    """
    Update the File with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{id}/download',
    description=""" Download a file.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_file_download(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    image_size: Optional[
        constr(pattern=r'^[1-9]{1}[0-9]{1,3}x[1-9]{1}[0-9]{1,3}$')
    ] = Query(None, alias='imageSize'),
):
    """
    Download a file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{id}/download{extension}',
    description=""" Download image in specific format. Images are converted server-side.
 """,
    tags=['file_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_file_download_extension(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    extension: Extension = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Download image in specific format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices',
    description=""" Retrieve a list of invoices.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices',
    description=""" Create an invoice.
 """,
    tags=[
        'invoice_management',
        'customer_invoice_management',
        'transaction_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Invoice = ...,
):
    """
    Create an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices/{id}',
    description=""" Retrieve an invoice with specified identifier string.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice(
    accept: Optional[Accept] = Header('application/json', alias='Accept'),
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/invoices/{id}',
    description=""" Create or update an invoice with predefined identifier string.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_invoice(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Invoice = ...,
):
    """
    Create or update an invoice with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/abandon',
    description=""" Abandon an invoice with specified identifier string.
 """,
    tags=['invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_abandonment(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Abandon an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/issue',
    description=""" Issue an invoice with specified identifier string. It must be in `draft` status.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_issuance(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceIssue = ...,
):
    """
    Issue an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices/{id}/items',
    description=""" Retrieve an invoice items with specified invoice identifier string.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice_item_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve invoice items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/items',
    description=""" Create an invoice item.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_item(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceItem = ...,
):
    """
    Create an invoice item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/recalculate',
    description=""" Recalculate an invoice with specified identifier string.
It will recalculate shipping rates, taxes, discounts. It is useful when coupon was revoked or customer redeemed coupon after invoice was issued and you want to apply it to this invoice.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_recalculation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Recalculate an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/reissue',
    description=""" Reissue an invoice with specified identifier string. It must be issued. (status must be `unpaid` or `past-due`).
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_reissuance(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceReissue = ...,
):
    """
    Reissue an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices/{id}/timeline',
    description=""" Retrieve a list of invoice timeline messages.
 """,
    tags=[
        'customer_timeline_management',
        'invoice_management',
        'transaction_timeline_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice_timeline_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    q: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of invoice timeline messages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/timeline',
    description=""" Create an invoice Timeline comment.
 """,
    tags=[
        'customer_timeline_management',
        'invoice_management',
        'customer_invoice_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceTimeline = ...,
):
    """
    Create an invoice Timeline comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/invoices/{id}/timeline/{messageId}',
    description=""" Delete an Invoice Timeline message with predefined identifier string.
 """,
    tags=[
        'customer_timeline_management',
        'invoice_management',
        'transaction_timeline_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_invoice_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete an Invoice Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices/{id}/timeline/{messageId}',
    description=""" Retrieve a invoice message with specified identifier string.
 """,
    tags=[
        'customer_timeline_management',
        'invoice_management',
        'customer_invoice_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an Invoice Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/transaction',
    description=""" Apply a transaction to an invoice. The invoice must be unpaid. The transaction must have a non-zero unused amount (not fully applied to other invoices).
 """,
    tags=['invoice_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_transaction(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceTransaction = ...,
):
    """
    Apply a transaction to an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/invoices/{id}/transaction-allocations',
    description=""" Get the precise amounts from a transaction allocated as invoice payments. """,
    tags=[
        'invoice_management',
        'transaction_management',
        'customer_invoice_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_invoice_transaction_allocation_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Get transaction amounts allocated to an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/invoices/{id}/void',
    description=""" Void an invoice with specified identifier string.
 """,
    tags=['invoice_management', 'customer_invoice_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_invoice_void(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Void an invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kyc-documents',
    description=""" Retrieve a list of KYC documents.
 """,
    tags=['kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_kyc_document_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of KYC documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-documents',
    description=""" Create a KYC Document.
 """,
    tags=['kyc_document_management', 'kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_document(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: KycDocument2 = ...,
):
    """
    Create a KYC Document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kyc-documents/{id}',
    description=""" Retrieve a KYC document with specified identifier string. """,
    tags=['kyc_document_management', 'kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_kyc_document(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a KYC Document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/kyc-documents/{id}',
    description=""" Create or update a KYC document with predefined identifier string. """,
    tags=['kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_kyc_document(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: KycDocument2 = ...,
):
    """
    Create or update a KYC document with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-documents/{id}/acceptance',
    description=""" Marks that status of the document as `accepted`. Updates the review time and reviewer information. Intended to be used for manual overrides.
 """,
    tags=['kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_document_acceptance(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Accept a KYC document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-documents/{id}/matches',
    description=""" Updates a KYC document's documentMatches. Intended to be used for manual overrides.
 """,
    tags=['kyc_document_management', 'kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_document_matches(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: KycDocumentsIdMatchesPostRequest = ...,
):
    """
    Update a KYC document's documentMatches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-documents/{id}/rejection',
    description=""" Marks that status of the document as `rejected`. Updates the review time and reviewer information. Intended to be used for manual overrides.
 """,
    tags=['kyc_document_management', 'kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_document_rejection(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: KycDocumentRejection = ...,
):
    """
    Reject a KYC document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-documents/{id}/review',
    description=""" Mark the KYC document as reviewed. Updates the review time and reviewer. information. """,
    tags=['kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_document_review(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Review a KYC document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kyc-requests',
    description=""" Retrieve a list of KYC requests.
 """,
    tags=['kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_kyc_request_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of KYC requests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/kyc-requests',
    description=""" Create a KYC Request.
 """,
    tags=['kyc_request_management', 'kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_kyc_request(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: KycRequest = ...,
):
    """
    Create a KYC Request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/kyc-requests/{id}',
    description=""" Delete the KYC request with the predefined identifier string.
 """,
    tags=['kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_kyc_request(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete the KYC request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/kyc-requests/{id}',
    description=""" Retrieve a KYC request with specified identifier string. """,
    tags=['kyc_request_management', 'kyc_document_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_kyc_request(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a KYC request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/kyc-requests/{id}',
    description=""" Update a KYC request. """,
    tags=['kyc_request_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_kyc_request(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Update a KYC request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/password-tokens',
    description=""" Retrieve a list of tokens.
 """,
    tags=['token_management', 'authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_password_token_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/password-tokens',
    description=""" Create a Reset Password Token.
 """,
    tags=['password_token_management', 'authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_password_token(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: ResetPasswordToken = ...,
):
    """
    Create a Reset Password Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/password-tokens/{id}',
    description=""" Delete a Reset Password Token with predefined identifier string.
 """,
    tags=['password_token_management', 'authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_password_token(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a Reset Password Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/password-tokens/{id}',
    description=""" Retrieve a Reset Password Token with specified identifier string.
 """,
    tags=['authentication_management', 'password_token_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_password_token(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Reset Password Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/payment-cards',
    description=""" Retrieve a list of Payments Cards.
 """,
    tags=['payment_card_management', 'payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_payment_card_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of Payment Cards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payment-cards',
    description=""" Create a Payment Card.
 """,
    tags=['payment_card_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_payment_card(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PaymentCardsPostRequest = ...,
):
    """
    Create a Payment Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/payment-cards/{id}',
    description=""" Retrieve a Payment Card with specified identifier string.
 """,
    tags=['payment_card_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_payment_card(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Payment Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/payment-cards/{id}',
    description=""" Update any of the payment card's values except for the pan.
 """,
    tags=['payment_card_management', 'payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_payment_card(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PaymentCardUpdatePlain = None,
):
    """
    Update a payment card's values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/payment-cards/{id}',
    tags=['payment_card_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_payment_card(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PaymentCardsIdPutRequest = None,
):
    """
    Create a payment card with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payment-cards/{id}/deactivation',
    description=""" Deactivate a Payment Card.
 """,
    tags=['payment_card_management', 'payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_payment_card_deactivation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Deactivate a Payment Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/payment-instruments',
    description=""" Retrieve a list of payment instruments.
 """,
    tags=['payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_payment_instrument_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of payment instruments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payment-instruments',
    description=""" Create a payment instrument.
If such payment card or bank account payment instrument already exists then updates it instead.
 """,
    tags=['payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_payment_instrument(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PaymentInstrumentsPostRequest = ...,
):
    """
    Create a Payment Instrument
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/payment-instruments/{id}',
    description=""" Retrieve a payment instrument by ID.
 """,
    tags=['payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_payment_instrument(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Payment Instrument
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/payment-instruments/{id}',
    description=""" Update allowed payment instrument's values. """,
    tags=['payment_instrument_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_payment_instrument(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PaymentInstrumentsIdPatchRequest = ...,
):
    """
    Update a Payment Instrument's values
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payment-instruments/{id}/deactivation',
    description=""" Deactivate a payment instrument.
 """,
    tags=['payment_instrument_management', 'payment_card_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_payment_instrument_deactivation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Deactivate a payment instrument
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payouts',
    description=""" Create a transaction of type `credit`.
 """,
    tags=['payout_creation', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_payout(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PayoutRequest = ...,
):
    """
    Create a credit transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/paypal-accounts',
    description=""" Retrieve a list of PayPal Accounts.
 """,
    tags=['paypal_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_pay_pal_account_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of PayPal accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/paypal-accounts',
    description=""" Create a PayPal Account.
 """,
    tags=['paypal_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_pay_pal_account(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PayPalAccount = ...,
):
    """
    Create a PayPal Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/paypal-accounts/{id}',
    description=""" Retrieve a PayPal Account with specified identifier string.
 """,
    tags=['paypal_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_pay_pal_account(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a PayPal Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/paypal-accounts/{id}',
    tags=['paypal_account_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_pay_pal_account(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: PayPalAccount = ...,
):
    """
    Create a PayPal account with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/paypal-accounts/{id}/deactivation',
    description=""" Deactivate a PayPal Account.
 """,
    tags=['paypal_account_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_pay_pal_account_deactivation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Deactivate a PayPal Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/plans',
    description=""" Retrieve a list of plans.
 """,
    tags=['plan_management', 'subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_plan_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of plans
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/plans',
    description=""" Create a plan.
 """,
    tags=['plan_management', 'subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_plan(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Plan = ...,
):
    """
    Create a plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/plans/{id}',
    description=""" Delete a Plan with predefined identifier string.
 """,
    tags=['plan_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_plan(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a Plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/plans/{id}',
    description=""" Retrieve a plan with specified identifier string.
 """,
    tags=['plan_management', 'subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_plan(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a plan
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/plans/{id}',
    description=""" Create or update a Plan with predefined identifier string.
 """,
    tags=['plan_management', 'subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_plan(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Plan = ...,
):
    """
    Create or update a Plan with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/products',
    description=""" Retrieve a list of products.
 """,
    tags=['product_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_product_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/products',
    description=""" Create a Product.
 """,
    tags=['product_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_product(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Product = ...,
):
    """
    Create a Product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/products/{id}',
    description=""" Delete a product with predefined identifier string.
 """,
    tags=['product_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_product(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/products/{id}',
    description=""" Retrieve a product with specified identifier string.
 """,
    tags=['product_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_product(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/products/{id}',
    description=""" Create a product with predefined identifier string.
 """,
    tags=['product_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_product(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Product = ...,
):
    """
    Create a product with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ready-to-pay',
    description=""" Get available payment methods for a specific transaction or a purchase.

The payment methods order shown to a customer **SHOULD** be the same as the order in the response.

The list of available methods is generated from available [Gateway Accounts](https://user-api-docs.rebilly.com/tag/Gateway-Accounts)
intersected with the last matched [Rules Engine](https://user-api-docs.rebilly.com/tag/Rules#operation/PutEventRule)
`adjust-ready-to-pay` action on `ready-to-pay-requested` event.

If there were no actions matched for the specific request  all methods supported by the Gateway Accounts are sent.

To invert this behavior  place an all-matching rule at the very end of the `ready-to-pay-requested` event in
Rules Engine with an empty `paymentMethods` property of the `adjust-ready-to-pay` action.
 """,
    tags=[
        'digital_wallet_validation',
        'payment_instrument_management',
        'transaction_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_ready_to_pay(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CoreReadyToPay = None,
):
    """
    Ready to Pay
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search',
    description=""" Search merchant's data to return resources such as customers, invoices, orders, transactions.
 """,
    tags=['merchant_data_search'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_search(
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Search merchant data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shipping-zones',
    description=""" Retrieve a list of shipping zones.
 """,
    tags=['shipping_zone_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_shipping_zone_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    q: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of shipping zones
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/shipping-zones',
    description=""" Create a Shipping Zone.
 """,
    tags=['shipping_zone_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_shipping_zone(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: ShippingZone = ...,
):
    """
    Create a Shipping Zone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/shipping-zones/{id}',
    description=""" Delete a shipping zone with predefined identifier string.
 """,
    tags=['shipping_zone_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_shipping_zone(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a shipping zone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/shipping-zones/{id}',
    description=""" Retrieve a shipping zone with specified identifier string.
 """,
    tags=['shipping_zone_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_shipping_zone(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a shipping zone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/shipping-zones/{id}',
    description=""" Create a shipping zone with predefined identifier string.
 """,
    tags=['shipping_zone_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_shipping_zone(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: ShippingZone = ...,
):
    """
    Create a shipping zone with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscription-cancellations',
    description=""" Retrieve a list of cancellations for all subscriptions. """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_cancellation_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of cancellations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscription-cancellations',
    description=""" Cancel an order or preview the cancellation parameters before that. """,
    tags=['subscription_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription_cancellation(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: SubscriptionCancellation = ...,
):
    """
    Cancel an order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/subscription-cancellations/{id}',
    description=""" Delete an order's cancellation. Only draft can be deleted. """,
    tags=['dispute_management', 'coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_subscription_cancellation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a cancellation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscription-cancellations/{id}',
    description=""" Retrieve an order ancellation with specified identifier string. """,
    tags=['coupon_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_cancellation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an order ancellation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/subscription-cancellations/{id}',
    description=""" Cancel a subscription. """,
    tags=['subscription_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_subscription_cancellation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: SubscriptionCancellation = ...,
):
    """
    Cancel an order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscription-reactivations',
    description=""" Retrieve a list of reactivations for all subscriptions. """,
    tags=['customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_reactivation_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of reactivations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscription-reactivations',
    description=""" Reactivate a subscription. """,
    tags=['subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription_reactivation(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: SubscriptionReactivation = ...,
):
    """
    Reactivate an order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscription-reactivations/{id}',
    description=""" Retrieve an order reactivation with specified identifier string. """,
    tags=['subscription_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_reactivation(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an order reactivation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions',
    description=""" Retrieve a list of orders.
 """,
    tags=['transaction_management', 'customer_management', 'subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_collection(
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    q: Optional[str] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions',
    description=""" Create an order. Consider using the upsert.
operation to accomplish this task.
 """,
    tags=['subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription(
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Subscription = ...,
):
    """
    Create an order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}',
    description=""" Retrieve an order with specified identifier string.
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription(
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/subscriptions/{id}',
    description=""" Create or update an order with predefined identifier string.
 """,
    tags=['subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def put_subscription(
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Subscription = ...,
):
    """
    Upsert an order with predefined ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions/{id}/change-items',
    description=""" Change an order's items or quantities and designate when and if there should be pro-rata credits given.
 """,
    tags=['subscription_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription_items_change(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: SubscriptionChange = ...,
):
    """
    Change an order's items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions/{id}/interim-invoice',
    description=""" Issue an interim invoice for a subscription, typically used in conjunction. with plan changes and pro rata adjustments.
This process creates an invoice, adds the subscription's line items to the invoice, and issues the invoice, and applies
payment to it if a transaction id is supplied.
 """,
    tags=[
        'invoice_management',
        'customer_invoice_management',
        'subscription_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription_interim_invoice(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: SubscriptionInvoice = ...,
):
    """
    Issue an interim invoice for a subscription order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}/timeline',
    description=""" Retrieve a list of order timeline messages.
 """,
    tags=['customer_timeline_management', 'transaction_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_timeline_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    sort: Optional[Sort] = None,
    q: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of order timeline messages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions/{id}/timeline',
    description=""" Create an order Timeline comment.
 """,
    tags=['customer_timeline_management', 'transaction_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_subscription_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: OrderTimeline = ...,
):
    """
    Create an order Timeline comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/subscriptions/{id}/timeline/{messageId}',
    description=""" Delete an Order Timeline message with predefined identifier string.
 """,
    tags=['customer_timeline_management', 'transaction_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_subscription_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete an Order Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}/timeline/{messageId}',
    description=""" Retrieve a order message with specified identifier string.
 """,
    tags=['transaction_timeline_management', 'customer_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve an Order Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{id}/upcoming-invoices',
    description=""" Retrieve an upcoming invoice from the specified subscription order.
The endpoint is temporary before upcoming invoices get a complete integration.
 """,
    tags=[
        'invoice_management',
        'customer_invoice_management',
        'subscription_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_subscription_upcoming_invoice_collection(
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve subscription order's upcoming invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions/{id}/upcoming-invoices/{invoiceId}/issue',
    description=""" Issue an upcoming invoice with specified identifier string for early pay.
 """,
    tags=[
        'invoice_management',
        'customer_invoice_management',
        'subscription_management',
    ],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_upcoming_invoice_issuance(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    invoice_id: str = Path(..., alias='invoiceId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: InvoiceIssue = ...,
):
    """
    Issue an upcoming invoice for early pay
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags',
    description=""" Retrieve a list of tags.
 """,
    tags=['tag_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_tag_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags',
    description=""" Create a tag.
 """,
    tags=['tag_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_tag(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Tag = ...,
):
    """
    Create a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{tag}',
    description=""" Delete a tag.
It's an asynchronous operation.
 """,
    tags=['tag_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_tag(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{tag}',
    description=""" Retrieve a tag.
 """,
    tags=['tag_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_tag(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/tags/{tag}',
    description=""" Update a tag.
 """,
    tags=['tag_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_tag(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: Tag = ...,
):
    """
    Update a tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{tag}/customers',
    description=""" Untag a list of customers.
If the customer from the list is already untagged it will be ignored.
It's an asynchronous operation.
 """,
    tags=['tag_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_tag_customer_collection(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TagsTagCustomersDeleteRequest = ...,
):
    """
    Untag a list of customers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{tag}/customers',
    description=""" Tag a list of customers.
If the customer from the list is already tagged it will be ignored.
It's an asynchronous operation.
 """,
    tags=['tag_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_tag_customer_collection(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TagsTagCustomersPostRequest = ...,
):
    """
    Tag a list of customers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{tag}/customers/{customerId}',
    description=""" Untag a customer.
 """,
    tags=['tag_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_tag_customer(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    customer_id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = Path(
        ..., alias='customerId'
    ),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Untag a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{tag}/customers/{customerId}',
    description=""" Tag a customer.
 """,
    tags=['tag_management', 'customer_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_tag_customer(
    tag: constr(pattern=r'^[@~\-\.\w\s]+$'),
    customer_id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = Path(
        ..., alias='customerId'
    ),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Tag a customer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tokens',
    description=""" Retrieve a list of tokens.
 """,
    tags=['token_management', 'authentication_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_token_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tokens',
    description=""" [FramePay](https://docs.rebilly.com/docs/developer-docs/framepay/)
is the recommended way to
create a payment token because it minimizes
PCI DSS compliance.  Once a payment token
is created, it can only be used once.

A payment token expires upon first use
or within 30 minutes of the token creation
(whichever comes first).
 """,
    tags=['token_management', 'payment_instrument_management'],
    security=[
        APIKeyHeader(name="Authorization"),
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_token(
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: CompositeToken = ...,
):
    """
    Create a payment token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tokens/{token}',
    description=""" Retrieve a token with specified identifier string.
 """,
    tags=['authentication_management', 'token_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_token(
    token: str,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions',
    description=""" Retrieve a list of transactions.
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_transaction_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    q: Optional[str] = None,
    sort: Optional[Sort] = None,
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions',
    description=""" Create a transaction of type `sale` or `authorize`.
This endpoint supports two main styles of transactions:
  1. A real-time decision and response.
  2. User approval/interaction is required.

A real-time decision is very familiar.  You send a request, and
inspect the `result` of the response for `approved` or `declined`.

However, many transactions, especially those for alternative
methods, require the user to interact with a 3rd party.  You
may be able to envision PayPal, for example, the user must
give permission to complete the payment (or accept the
billing agreement).

Even payment cards may require user approval in the case of
3D secure authentication.  In the event that approval is
required, you will receive a response back and notice
that the `result` is `unknown`.  You will find that the
`status` is `waiting-approval`. And you will find in the
`_links` section of the response a link for the `approvalUrl`.

In this case you would either open the `approvalUrl` in an
iframe or in a pop (better workflow for mobile).
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_transaction(
    expand: Optional[str] = None,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TransactionRequest = ...,
):
    """
    Create a transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/{id}',
    description=""" Retrieve a Transaction with specified identifier string.
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_transaction(
    expand: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/transactions/{id}',
    description=""" Update a transaction's custom fields.
 """,
    tags=['transaction_management', 'transaction_status_updates'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def patch_transaction(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TransactionsIdPatchRequest = ...,
):
    """
    Update a transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/{id}/query',
    description=""" Query a Transaction with a specified identifier string.
The query will contact the gateway account to find the result and amount/currency.
The response should be analyzed.  If deemed appropriate, the transaction could be updated using the Transaction Update API.
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_transaction_query(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Query a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/{id}/refund',
    description=""" Refund a Transaction with specified identifier string.
Note that the refund will be in the same currency as the original transaction.
 """,
    tags=['transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_transaction_refund(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TransactionRefund = ...,
):
    """
    Refund a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/{id}/timeline',
    description=""" Retrieve a list of transaction timeline messages.
 """,
    tags=['transaction_timeline_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_transaction_timeline_collection(
    limit: Optional[conint(ge=0, le=1000)] = None,
    offset: Optional[conint(ge=0)] = None,
    filter: Optional[str] = None,
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50) = ...,
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a list of transaction timeline messages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/{id}/timeline',
    description=""" Create a transaction Timeline comment.
 """,
    tags=['transaction_timeline_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_transaction_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TransactionTimeline = ...,
):
    """
    Create a transaction Timeline comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/transactions/{id}/timeline/{messageId}',
    description=""" Delete a Transaction Timeline message with predefined identifier string.
 """,
    tags=['transaction_timeline_management', 'transaction_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def delete_transaction_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Delete a Transaction Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/{id}/timeline/{messageId}',
    description=""" Retrieve a timeline message with specified identifier string.
 """,
    tags=['transaction_management', 'transaction_timeline_management'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def get_transaction_timeline(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    message_id: str = Path(..., alias='messageId'),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
):
    """
    Retrieve a transaction Timeline message
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/{id}/update',
    description=""" Update a Transaction manually to completed status with given result with optional currency and amount. """,
    tags=['transaction_management', 'transaction_status_updates'],
    security=[
        APIKeyHeader(name="REB-APIKEY"),
        HTTPBearer(name="None"),
    ],
)
def post_transaction_update(
    id: constr(pattern=r'^[@~\-\.\w]+$', max_length=50),
    organization__id: Optional[ResourceId] = Header(None, alias='Organization-Id'),
    body: TransactionUpdate = ...,
):
    """
    Update a Transaction status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
